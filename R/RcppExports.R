# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' vector_factor_addition
#'
#' @param x vector 
#' @param summand numerical
#' @return a vector containing the sum of each element in x and the summand
#'
NULL

#' vector_vector_addition
#'
#' @param x vector 
#' @param y vector
#' @return a vector containing at each position i the sum of x[i] + y[i]
#'
NULL

#' vector_factor_multiplication
#'
#' @param x vector 
#' @param factor numerical
#' @return a vector containing the product of each element in x and the factor
#'
NULL

#' vector_vector_multiplication
#'
#' @param x vector 
#' @param y vector
#' @return a vector containing at each position i the product  x[i] * y[i]
#'
NULL

#' vector_vector_subtract
#'
#' @param x vector 
#' @param y vector
#' @return vector representing the subtraction x - y
#'
NULL

#' vector_factor_division
#'
#' @param x vector 
#' @param divisor numerical
#' @return a vector containing the result of each 
#'   element in x divided by divisor
#'
NULL

#' vector_vector_division
#'
#' @param x vector 
#' @param y vector
#' @return a vector containing the product of each element
#'   in x and the factor
#'
NULL

#' vector_pow
#'
#' @param x vector 
#' @param exp numerical representing the exponent
#' @return a vector containing a copy of x with each 
#'   element raised to the power of exp
#'
NULL

#' vector_sum
#'
#' @param x vector with numerical elements 
#' @return The sum of all elements in x
#'
NULL

#' vector_mean
#'
#' @param x vector with numericals
#' @return the average of all elements in x
#'
NULL

#' vector_standard_deviation
#'
#' @param x vector with numericals
#' @return the standard deviation of all elements in x
#'
NULL

#' vector_absolute
#'
#' @param x vector with numericals
#' @return vector with the absolute values of all elements in x
#'
NULL

#' max
#'
#' @param x unsorted vector with numerals
#' @return the maximum value in x
NULL

#' min
#'
#' @param x unsorted vector with numerals
#' @return the minimum value in x
NULL

#' Repeat weighted
#'
#' Each element x[i] in the given input vector x is repeated according
#' to the weight vector at position i
#'
#' @param x vector with numeric elements
#' @param freq_table vector<int> representing the numer of repeats
#' @return the weight-repeated NumericVector of x
#'
NULL

#' vector_concatenate
#'
#' `concat` returns a vector that represents the concatenation of two input
#' vectors. The elements of the second given vector are appended to a copy of
#' the first vector.
#'
#' @param x vector
#' @param y vector
#' @return concatenation of y after x
#'
NULL

#' vector_vector_correlation
#'
#' @param x vector with numericals
#' @param y vector with numericals
#' @param mean_x optional pre-calculated mean of x
#' @param mean_y optional pre-calculated mean of y
#' @return pearsons correlation of the vectors x and y
#'
NULL

#' vector_cumulative_sum
#' 
#' The cumulative sum x[i] is the sum of all previous elements in x:
#' x[i] = x[i-1] + x[i-2] + ... + x[0]
#'
#' @param x vector of numericals
#' @return a vector containing cumulative sums of the values in x
#'
NULL

#' interval_table
#'
#' Given a vector datavec and a vector with interval breaks,
#' a histogram with the number of elements in datavec that fall into each
#' of the intervals is returned.
#'
#' @param datavec vector with elements to be distributed over the intervals
#' @param interval_breaks vector with n interval_borders that are
#'  interpreted as interval breaks:\cr 
#' (-Inf, breaks[0]], (breaks[0], breaks[1]), ... , (breaks(n), Inf)
#' @param ini_value default frequency value
#'
#' @return frequency with which elements of datavec fall into each of the 
#'  intervals defined by interval_breaks
#'
NULL

#' permutations
#'
#' Returns permutations of a given NumericVector as columns in a NumericMatrix
#' object.
#' @param x NumericVector representing a vector that is to be permutated
#' @param num_permutations Integer representing the number of permutations
#' that are to be performed.
#' @return a matrix containing in every column one permutations of the
#' input vector
#'
#' @examples
#' x <- seq(1:10)
#' m <- permutations(x, 5)
#' dim(m)
#' #[1] 10  5
#'
#' @export
permutations <- function(x, num_permutations) {
    .Call('_waddR_permutations', PACKAGE = 'waddR', x, num_permutations)
}

#' squared_wass_decomp
#'
#' Approximation of the squared Wasserstein distance \eqn{d_g}{W_g} between
#' two vectors decomposed into size, location and shape.
#' Calculation based on the mean squared difference between the equidistant
#' quantiles of the two input vectors a and b.
#' As an approximation of the distribution, 1000 quantiles are computed for
#' each vector.
#'
#' @param x Vector representing an empirical distribution under condition A
#' @param y Vector representing an empirical distribution under condition B
#' @return An named Rcpp::List with the wasserstein distance between x and y,
#' decomposed into terms for size, location, and shape
#' 
#' @references 
#' Schefzik and Goncalves 2019
#' Irpino and Verde (2015)
#'
#' @seealso [wasserstein_metric()], [squared_wass_approx()] for
#' different implementations of the wasserstein distance
#'
#' @examples
#' # input: one dimensional data in two conditions
#' x <- rnorm(100, 42, 2)
#' y <- c(rnorm(61, 20, 1), rnorm(41, 40,2))
#' # output: squared Wasserstein distance decomposed into terms for location,
#' # shape, size
#' d.wass.decomp <- squared_wass_decomp(x,y,2)
#' d.wass.decomp$location
#' d.wass.decomp$size
#' d.wass.decomp$shade
#' 
#' @export
squared_wass_decomp <- function(x, y) {
    .Call('_waddR_squared_wass_decomp', PACKAGE = 'waddR', x, y)
}

#' squared_wass_approx
#'
#' Approximation of the squared wasserstein distance.
#' Calculation based on the mean squared difference between the equidistant
#' empirical quantiles of the two input vectors a and b.
#' As an approximation of the quantile function, 1000 quantiles are computed
#' for each vector.
#'
#' @param x Vector representing an empirical distribution under condition A
#' @param y Vector representing an empirical distribution under condition B
#' @return The approximated squared wasserstein distance between x and y
#'
#' @references Schefzik and Goncalves 2019
#'
#' @seealso [wasserstein_metric()], [squared_wass_decomp()] for
#' different implementations of the wasserstein distance
#'
#' @examples
#' # input: one dimensional data in two conditions
#' x <- rnorm(100, 42, 2)
#' y <- c(rnorm(61, 20, 1), rnorm(41, 40,2))
#' # output: The squared Wasserstein distance approximated as described in
#' # Schefzik and Goncalves 2019
#' d.wass.approx <- squared_wass_approx(x,y,2)
#'
#' @export
squared_wass_approx <- function(x, y) {
    .Call('_waddR_squared_wass_approx', PACKAGE = 'waddR', x, y)
}

#' wasserstein_metric
#'
#' The order \code{p} Wasserstein metric (or distance) is defined as the 
#' \code{p}-th root of the total cost of turning one pile of mass x into a new
#' pile of mass y.
#' The cost a single trnasport \eqn{x_i} into \eqn{y_i} is the \code{p}-th
#' power of the euclidean distance between \eqn{x_i} and \eqn{y_i}.
#' 
#' The masses in \eqn{x} and \eqn{y} can also be represented as clusters
#' \eqn{P} and \eqn{Q} with weights \eqn{W_P} and \eqn{W_Q}.
#' The wasserstein distance then becomes the optimal flow F, which is the sum
#' of all optimal flows \eqn{f_{ij}} from \eqn{(p_i, w_{p,i})} to
#' \eqn{(q_i, w_{q,i})}.
#'
#' This implementation of the Wasserstein metric is a Rcpp reimplementation of
#' the wasserstein1d function by Dominic Schuhmacher from the package
#' transport.
#' 
#' @param x NumericVector representing an empirical distribution under
#' condition A
#' @param y NumericVector representing an empirical distribution under
#' condition B
#' @param p order of the wasserstein distance
#' @param wa_ NumericVector representing the weights of datapoints
#'  (interpreted as clusters) in x
#' @param wb_ NumericVector representing the weights of datapoints
#'  (interpreted as clusters) in y
#' @return The wasserstein (transport) distance between x and y
#'
#' @references Schefzik and Goncalves 2019
#'
#' @seealso [squared_wass_approx()], [squared_wass_decomp()] for
#' different approximations of the wasserstein distance
#'
#' @examples
#' # input: one dimensional data in two conditions
#' x <- rnorm(100, 42, 2)
#' y <- c(rnorm(61, 20, 1), rnorm(41, 40, 2))
#' # output: The exact Wasserstein distance between the two input
#' # vectors. Reimplementation of the wasserstein1d function found in
#' # the packge transport.
#' d.wass <- wasserstein_metric(x,y,2)
#'
#' @export
wasserstein_metric <- function(x, y, p = 1, wa_ = NULL, wb_ = NULL) {
    .Call('_waddR_wasserstein_metric', PACKAGE = 'waddR', x, y, p, wa_, wb_)
}

add_test_export <- function(x_, y_) {
    .Call('_waddR_add_test_export', PACKAGE = 'waddR', x_, y_)
}

add_test_export_sv <- function(x_, summand_) {
    .Call('_waddR_add_test_export_sv', PACKAGE = 'waddR', x_, summand_)
}

multiply_test_export <- function(x_, y_) {
    .Call('_waddR_multiply_test_export', PACKAGE = 'waddR', x_, y_)
}

multiply_test_export_sv <- function(x_, factor_) {
    .Call('_waddR_multiply_test_export_sv', PACKAGE = 'waddR', x_, factor_)
}

pow_test_export <- function(x_, exp) {
    .Call('_waddR_pow_test_export', PACKAGE = 'waddR', x_, exp)
}

abs_test_export <- function(x_) {
    .Call('_waddR_abs_test_export', PACKAGE = 'waddR', x_)
}

sum_test_export <- function(x_) {
    .Call('_waddR_sum_test_export', PACKAGE = 'waddR', x_)
}

subtract_test_export <- function(x_, y_) {
    .Call('_waddR_subtract_test_export', PACKAGE = 'waddR', x_, y_)
}

divide_test_export_sv <- function(x_, y_) {
    .Call('_waddR_divide_test_export_sv', PACKAGE = 'waddR', x_, y_)
}

divide_test_export_vectors <- function(x_, y_) {
    .Call('_waddR_divide_test_export_vectors', PACKAGE = 'waddR', x_, y_)
}

mean_test_export <- function(x_) {
    .Call('_waddR_mean_test_export', PACKAGE = 'waddR', x_)
}

sd_test_export <- function(x_) {
    .Call('_waddR_sd_test_export', PACKAGE = 'waddR', x_)
}

cumSum_test_export <- function(x_, last_index = 0L) {
    .Call('_waddR_cumSum_test_export', PACKAGE = 'waddR', x_, last_index)
}

cor_test_export <- function(x_, y_) {
    .Call('_waddR_cor_test_export', PACKAGE = 'waddR', x_, y_)
}

rep_weighted_test_export <- function(x_, weights_) {
    .Call('_waddR_rep_weighted_test_export', PACKAGE = 'waddR', x_, weights_)
}

concat_test_export <- function(x_, y_) {
    .Call('_waddR_concat_test_export', PACKAGE = 'waddR', x_, y_)
}

interval_table_test_export <- function(data_, breaks_, default_freq = 0L) {
    .Call('_waddR_interval_table_test_export', PACKAGE = 'waddR', data_, breaks_, default_freq)
}

equidist_quantile_test_export <- function(x_, K, d = 0, type = 1L) {
    .Call('_waddR_equidist_quantile_test_export', PACKAGE = 'waddR', x_, K, d, type)
}

quantile_test_export <- function(x_, q_, type = 1L) {
    .Call('_waddR_quantile_test_export', PACKAGE = 'waddR', x_, q_, type)
}

